<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Igloo Style Scroll 3D Lab</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: dark;
        --bg: #03050f;
        --fg: #f4f7ff;
        --accent: #8cf3ff;
        --accent-2: #a079ff;
        --glass: rgba(6, 11, 27, 0.65);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Space Grotesk", system-ui, -apple-system, BlinkMacSystemFont,
          "Segoe UI", sans-serif;
        background: radial-gradient(circle at top, #08132d, var(--bg) 60%);
        color: var(--fg);
        min-height: 100vh;
        overflow-x: hidden;
      }

      canvas#space-stage {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        pointer-events: none;
        z-index: 0;
      }

      header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        padding: 1.25rem clamp(1.5rem, 3vw, 4rem);
        display: flex;
        justify-content: space-between;
        align-items: center;
        mix-blend-mode: difference;
        z-index: 2;
      }

      header h1 {
        font-size: clamp(1rem, 2vw, 1.35rem);
        letter-spacing: 0.25rem;
        text-transform: uppercase;
      }

      header span {
        font-size: 0.9rem;
        opacity: 0.8;
      }

      main {
        position: relative;
        z-index: 1;
        padding: 0 clamp(1.5rem, 4vw, 5rem);
      }

      section.panel {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 1.5rem;
        padding-top: 4rem;
      }

      section.hero h2 {
        font-size: clamp(3.3rem, 8vw, 6.5rem);
        line-height: 1;
        max-width: 15ch;
      }

      section.hero p {
        font-size: clamp(1rem, 1.4vw, 1.3rem);
        max-width: 48ch;
        opacity: 0.85;
      }

      .cta {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
      }

      .cta a {
        text-decoration: none;
        padding: 0.95rem 1.8rem;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: var(--fg);
        font-weight: 600;
        backdrop-filter: blur(6px);
        transition: transform 0.35s ease, box-shadow 0.35s ease,
          border-color 0.35s ease;
      }

      .cta a.primary {
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        color: #060712;
        border-color: transparent;
        box-shadow: 0 20px 60px rgba(140, 243, 255, 0.35);
      }

      .cta a:hover {
        transform: translateY(-4px) scale(1.02);
        border-color: rgba(255, 255, 255, 0.7);
      }

      section.info-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1.5rem;
      }

      .info-card {
        padding: 1.5rem;
        border-radius: 1.2rem;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: var(--glass);
        backdrop-filter: blur(16px);
        min-height: 200px;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .info-card h3 {
        font-size: 1.2rem;
      }

      .info-card p {
        font-size: 0.95rem;
        opacity: 0.75;
      }

      section.timeline {
        gap: 2rem;
      }

      .timeline-step {
        position: relative;
        padding-left: 2.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .timeline-step::before {
        content: "";
        position: absolute;
        left: 0.8rem;
        top: 0.35rem;
        width: 0.6rem;
        height: 0.6rem;
        border-radius: 50%;
        background: var(--accent);
        box-shadow: 0 0 0 10px rgba(140, 243, 255, 0.12);
      }

      .timeline-step::after {
        content: "";
        position: absolute;
        left: 1.05rem;
        top: 1.4rem;
        bottom: -1.6rem;
        width: 2px;
        background: linear-gradient(var(--accent), rgba(255, 255, 255, 0));
      }

      .timeline-step:last-child::after {
        display: none;
      }

      footer {
        min-height: 60vh;
        display: grid;
        place-items: center;
        text-align: center;
        gap: 1rem;
        padding-bottom: 4rem;
      }

      footer h3 {
        font-size: clamp(2.2rem, 5vw, 4rem);
      }

      .scroll-hint {
        position: fixed;
        bottom: 2rem;
        left: 50%;
        transform: translateX(-50%);
        text-transform: uppercase;
        letter-spacing: 0.45rem;
        font-size: 0.75rem;
        opacity: 0.65;
        animation: float 2.8s ease-in-out infinite;
        z-index: 2;
        pointer-events: none;
      }

      @keyframes float {
        0%,
        100% {
          transform: translate(-50%, 0);
        }
        50% {
          transform: translate(-50%, -12px);
        }
      }

      @media (max-width: 640px) {
        header {
          flex-direction: column;
          gap: 0.25rem;
          align-items: flex-start;
        }

        header h1 {
          letter-spacing: 0.15rem;
        }

        .timeline-step {
          padding-left: 1.75rem;
        }

        .timeline-step::before {
          left: 0.2rem;
        }

        .timeline-step::after {
          left: 0.35rem;
        }
      }
    </style>
  </head>
  <body>
    <canvas id="space-stage"></canvas>

    <header>
      <h1>IGLU.EXPERIMENT</h1>
      <span>Scroll-native 3D Lab</span>
    </header>

    <main>
      <section class="panel hero">
        <p>Prototype/2025</p>
        <h2>
          Eksperimen Scroll 3D untuk narasi imersif ala Igloo Interactive Studio
        </h2>
        <p>
          Canvas merespon progres scroll dengan koreografi kamera, mesh, dan
          partikel. Gunakan halaman ini untuk menguji ide storyline, trigger
          pinning, hingga transisi warna.
        </p>
        <div class="cta">
          <a class="primary" href="#modules">Lihat Modul</a>
          <a href="#timeline">Detail Teknis</a>
        </div>
      </section>

      <section id="modules" class="panel info-grid">
        <article class="info-card">
          <h3>01 · Scene Core</h3>
          <p>
            Three.js dengan fog eksponensial untuk mood ruang gelap berpendar dan
            depth natural.
          </p>
        </article>
        <article class="info-card">
          <h3>02 · Scroll Driver</h3>
          <p>
            Rasio scroll global diterjemahkan ke posisi kamera, rotasi mesh, dan
            orbit partikel.
          </p>
        </article>
        <article class="info-card">
          <h3>03 · Responsives</h3>
          <p>
            Layout copy memanfaatkan clamp() & auto-fit grid; canvas tetap
            fullscreen.
          </p>
        </article>
        <article class="info-card">
          <h3>04 · Motion Safety</h3>
          <p>
            Jika prefers-reduced-motion aktif, animasi diperlambat tanpa mematikan
            pengalaman.
          </p>
        </article>
      </section>

      <section id="timeline" class="panel timeline">
        <div class="timeline-step">
          <strong>Scroll hook → 0–1</strong>
          <p>ScrollY dibanding total dokumen menghasilkan progress normal.</p>
        </div>
        <div class="timeline-step">
          <strong>Easing/lerp</strong>
          <p>Lerp sederhana meredam jitter saat pergantian bagian.</p>
        </div>
        <div class="timeline-step">
          <strong>Camera choreography</strong>
          <p>
            Sumbu X/Y memanfaatkan sinus-kosinus, Z mendekat saat akhir untuk efek
            parallax.
          </p>
        </div>
        <div class="timeline-step">
          <strong>Portal & shards</strong>
          <p>
            Portal shader dan monolit neon bereaksi terhadap progress scroll
            sebagai aksen Igloo.
          </p>
        </div>
      </section>

      <footer class="panel">
        <p>Next</p>
        <h3>Tambah teks, glTF, atau modul pin animasi lainnya.</h3>
        <p>Seluruh logika dalam satu file sehingga mudah dimodifikasi.</p>
      </footer>
    </main>

    <div class="scroll-hint">Scroll</div>

    <script src="https://unpkg.com/three@0.160.1/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.160.1/examples/js/postprocessing/Pass.js"></script>
    <script src="https://unpkg.com/three@0.160.1/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.160.1/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.160.1/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.160.1/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.160.1/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.160.1/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.160.1/examples/js/shaders/FilmShader.js"></script>
    <script src="https://unpkg.com/three@0.160.1/examples/js/postprocessing/FilmPass.js"></script>
    <script>
      const canvas = document.getElementById("space-stage");
      const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
        alpha: true,
      });
      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x050915, 0.08);

      // Kubah langit custom shader untuk gradasi dinamis
      const skyUniforms = { time: { value: 0 } };
      const skyMaterial = new THREE.ShaderMaterial({
        uniforms: skyUniforms,
        side: THREE.BackSide,
        vertexShader: `
          varying vec3 vPos;
          void main() {
            vPos = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          varying vec3 vPos;
          uniform float time;
          void main() {
            vec3 dir = normalize(vPos);
            float gradient = smoothstep(-0.5, 0.8, dir.y);
            vec3 deep = vec3(0.02, 0.03, 0.08);
            vec3 mid = vec3(0.06, 0.1, 0.25);
            vec3 top = vec3(0.45 + 0.1 * sin(time * 0.15), 0.12, 0.55);
            vec3 color = mix(mix(deep, mid, gradient), top, pow(gradient, 1.2));
            float glow = pow(1.0 - gradient, 2.0) * 0.25;
            gl_FragColor = vec4(color + glow, 1.0);
          }
        `,
      });
      const skyMesh = new THREE.Mesh(new THREE.SphereGeometry(40, 64, 64), skyMaterial);
      scene.add(skyMesh);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 0, 6);

      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.15;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.physicallyCorrectLights = true;

      const composerReady =
        THREE.EffectComposer &&
        THREE.RenderPass &&
        THREE.UnrealBloomPass &&
        THREE.FilmPass;
      let composer = null;
      let bloomPass = null;
      let filmPass = null;
      if (composerReady) {
        composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);
        bloomPass = new THREE.UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.1,
          0.8,
          0.01
        );
        composer.addPass(bloomPass);
        filmPass = new THREE.FilmPass(0.18, 0.35, 648, false);
        filmPass.renderToScreen = true;
        composer.addPass(filmPass);
      } else {
        console.warn(
          "Post-processing assets belum termuat; renderer fallback tanpa bloom/film."
        );
      }

      const reduceMotion = window.matchMedia(
        "(prefers-reduced-motion: reduce)"
      ).matches;

      const pointer = { x: 0, y: 0 };
      window.addEventListener("pointermove", (event) => {
        const { innerWidth: w, innerHeight: h } = window;
        pointer.x = (event.clientX / w - 0.5) * 2;
        pointer.y = (event.clientY / h - 0.5) * 2;
      });

      const paletteStops = [
        {
          progress: 0,
          portalA: new THREE.Color(0x0f9dff),
          portalB: new THREE.Color(0xff5fec),
          waterDeep: new THREE.Color(0x020812),
          waterGlow: new THREE.Color(0x1abfff),
          rim: new THREE.Color(0xff4fb0),
          ambient: new THREE.Color(0x16263b),
          key: new THREE.Color(0xb7d0ff),
          spot: new THREE.Color(0x7dfbff),
        },
        {
          progress: 0.45,
          portalA: new THREE.Color(0x58ffd7),
          portalB: new THREE.Color(0xffc45b),
          waterDeep: new THREE.Color(0x040b14),
          waterGlow: new THREE.Color(0x58ffd7),
          rim: new THREE.Color(0xff6f8a),
          ambient: new THREE.Color(0x142035),
          key: new THREE.Color(0xb6c5ff),
          spot: new THREE.Color(0x9effff),
        },
        {
          progress: 1,
          portalA: new THREE.Color(0x6b7bff),
          portalB: new THREE.Color(0xff79d5),
          waterDeep: new THREE.Color(0x070716),
          waterGlow: new THREE.Color(0xcc86ff),
          rim: new THREE.Color(0xff9b4f),
          ambient: new THREE.Color(0x0f1735),
          key: new THREE.Color(0xe3ecff),
          spot: new THREE.Color(0xfff1b4),
        },
      ];

      const lerpColor = (out, c1, c2, t) => out.copy(c1).lerp(c2, t);
      const paletteColorA = new THREE.Color();
      const paletteColorB = new THREE.Color();
      const paletteDeep = new THREE.Color();
      const paletteGlow = new THREE.Color();
      const paletteRim = new THREE.Color();
      const paletteAmbient = new THREE.Color();
      const paletteKey = new THREE.Color();
      const paletteSpot = new THREE.Color();

      const applyPalette = (progress) => {
        const t = THREE.MathUtils.clamp(progress, 0, 1);
        let lower = paletteStops[0];
        let upper = paletteStops[paletteStops.length - 1];
        for (let i = 0; i < paletteStops.length - 1; i++) {
          if (t >= paletteStops[i].progress && t <= paletteStops[i + 1].progress) {
            lower = paletteStops[i];
            upper = paletteStops[i + 1];
            break;
          }
        }
        const span = Math.max(upper.progress - lower.progress, 0.0001);
        const mix = (t - lower.progress) / span;
        lerpColor(paletteColorA, lower.portalA, upper.portalA, mix);
        lerpColor(paletteColorB, lower.portalB, upper.portalB, mix);
        lerpColor(paletteDeep, lower.waterDeep, upper.waterDeep, mix);
        lerpColor(paletteGlow, lower.waterGlow, upper.waterGlow, mix);
        lerpColor(paletteRim, lower.rim, upper.rim, mix);
        lerpColor(paletteAmbient, lower.ambient, upper.ambient, mix);
        lerpColor(paletteKey, lower.key, upper.key, mix);
        lerpColor(paletteSpot, lower.spot, upper.spot, mix);

        portalUniforms.uColorA.value.copy(paletteColorA);
        portalUniforms.uColorB.value.copy(paletteColorB);
        waterUniforms.deepColor.value.copy(paletteDeep);
        waterUniforms.glowColor.value.copy(paletteGlow);
        rimLight.color.copy(paletteRim);
        ambient.color.copy(paletteAmbient);
        keyLight.color.copy(paletteKey);
        spotLight.color.copy(paletteSpot);
      };
      function createHelixLine(radius, height, turns, colorHex, opacity) {
        const points = [];
        const segments = 400;
        for (let i = 0; i <= segments; i++) {
          const t = (i / segments) * Math.PI * turns;
          const y = -height / 2 + (height * i) / segments;
          const wobble = 0.12 * Math.sin(i * 0.08);
          points.push(
            new THREE.Vector3(
              Math.cos(t) * (radius + wobble),
              y,
              Math.sin(t) * (radius - wobble)
            )
          );
        }
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        return new THREE.Line(
          geometry,
          new THREE.LineBasicMaterial({
            color: colorHex,
            transparent: true,
            opacity,
          })
        );
      }

      const portalUniforms = {
        uTime: { value: 0 },
        uScroll: { value: 0 },
        uColorA: { value: paletteStops[0].portalA.clone() },
        uColorB: { value: paletteStops[0].portalB.clone() },
      };
      const portalMaterial = new THREE.ShaderMaterial({
        uniforms: portalUniforms,
        transparent: true,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
        vertexShader: `
          varying vec2 vUv;
          uniform float uScroll;
          void main() {
            vUv = uv;
            vec3 pos = position;
            pos.z += sin((uv.x + uScroll) * 8.0) * 0.08;
            pos.y += cos((uv.y + uScroll) * 4.0) * 0.08;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }
        `,
        fragmentShader: `
          varying vec2 vUv;
          uniform float uTime;
          uniform float uScroll;
          uniform vec3 uColorA;
          uniform vec3 uColorB;
          void main() {
            float rim = smoothstep(0.25, 0.95, vUv.y);
            float pulse = 0.5 + 0.5 * sin(uTime * 2.4 + vUv.x * 12.0);
            vec3 color = mix(uColorA, uColorB, vUv.x + uScroll * 0.4);
            float alpha = rim * 0.75 + pulse * 0.25;
            if (alpha < 0.05) discard;
            gl_FragColor = vec4(color * alpha, alpha);
          }
        `,
      });
      const portalGeometry = new THREE.RingGeometry(1.05, 1.8, 256, 1);
      const portalMesh = new THREE.Mesh(portalGeometry, portalMaterial);
      portalMesh.rotation.x = Math.PI / 2;
      scene.add(portalMesh);

      const haloMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.22,
        side: THREE.DoubleSide,
      });
      const halo = new THREE.Mesh(new THREE.RingGeometry(1.9, 2.45, 128), haloMaterial);
      halo.rotation.x = Math.PI / 2;
      scene.add(halo);

      const helixGroup = new THREE.Group();
      const helixA = createHelixLine(1.25, 3.6, 5.5, 0x7dfbff, 0.55);
      const helixB = createHelixLine(1.5, 3.6, 5.5, 0xff7ee7, 0.35);
      helixB.rotation.y = Math.PI / 2;
      helixGroup.add(helixA);
      helixGroup.add(helixB);
      scene.add(helixGroup);

      const waterUniforms = {
        time: { value: 0 },
        scroll: { value: 0 },
        deepColor: { value: paletteStops[0].waterDeep.clone() },
        glowColor: { value: paletteStops[0].waterGlow.clone() },
      };
      const water = new THREE.Mesh(
        new THREE.PlaneGeometry(24, 24, 200, 200),
        new THREE.ShaderMaterial({
          uniforms: waterUniforms,
          transparent: true,
          depthWrite: false,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending,
          vertexShader: `
            varying vec2 vUv;
            varying float vHeight;
            uniform float time;
            uniform float scroll;

            void main() {
              vUv = uv;
              vec3 pos = position;
              float wave1 = sin((pos.x + scroll * 8.0) * 0.6 + time * 1.2) * 0.18;
              float wave2 = cos((pos.y - scroll * 6.0) * 0.8 + time * 1.4) * 0.12;
              float radial = sin(length(pos.xy) * 0.9 - time * 0.9) * 0.1;
              pos.z += wave1 + wave2 + radial;
              vHeight = pos.z;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
          `,
          fragmentShader: `
            varying vec2 vUv;
            varying float vHeight;
            uniform float time;
            uniform vec3 deepColor;
            uniform vec3 glowColor;
            void main() {
              float gridX = smoothstep(0.02, 0.0, abs(fract(vUv.x * 25.0) - 0.5));
              float gridY = smoothstep(0.02, 0.0, abs(fract(vUv.y * 25.0) - 0.5));
              float grid = (gridX + gridY) * 0.15;
              float fresnel = smoothstep(0.0, 0.8, vHeight + 0.5);
              vec3 color = mix(deepColor, glowColor, fresnel + grid);
              gl_FragColor = vec4(color, 0.7);
            }
          `,
        })
      );
      water.rotation.x = -Math.PI / 2;
      water.position.y = -1.3;
      scene.add(water);

      const lightCone = new THREE.Mesh(
        new THREE.ConeGeometry(2.1, 6, 64, 1, true),
        new THREE.MeshBasicMaterial({
          color: 0x7ef8ff,
          transparent: true,
          opacity: 0.22,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          side: THREE.DoubleSide,
        })
      );
      lightCone.position.set(0, 1.4, -0.4);
      lightCone.rotation.x = Math.PI;
      scene.add(lightCone);

      const orbGroup = new THREE.Group();
      for (let i = 0; i < 3; i++) {
        const orb = new THREE.Mesh(
          new THREE.SphereGeometry(0.22 + i * 0.05, 32, 32),
          new THREE.MeshStandardMaterial({
            color: new THREE.Color().setHSL(0.5 + i * 0.08, 0.85, 0.6),
            metalness: 0.3,
            roughness: 0.1,
            emissive: 0x1a6bff,
            emissiveIntensity: 1.6,
          })
        );
        orb.castShadow = true;
        orbGroup.add(orb);
      }
      scene.add(orbGroup);

      const nebulaGroup = new THREE.Group();
      const nebulaUniforms = [];
      for (let i = 0; i < 5; i++) {
        const uniforms = {
          time: { value: 0 },
          noiseShift: { value: Math.random() * 10 },
          opacity: { value: 0.4 + Math.random() * 0.25 },
        };
        nebulaUniforms.push(uniforms);
        const nebula = new THREE.Mesh(
          new THREE.PlaneGeometry(6 + Math.random() * 2, 3 + Math.random() * 1.5, 1, 1),
          new THREE.ShaderMaterial({
            uniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide,
            vertexShader: `
              varying vec2 vUv;
              void main() {
                vUv = uv;
                vec3 pos = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
              }
            `,
            fragmentShader: `
              varying vec2 vUv;
              uniform float time;
              uniform float noiseShift;
              uniform float opacity;
              float noise(vec2 p) {
                return sin(p.x) * sin(p.y);
              }
              void main() {
                vec2 uv = vUv * 4.0;
                float n = noise(uv + time * 0.15 + noiseShift);
                float glow = smoothstep(0.0, 1.0, n * 0.5 + 0.5);
                float edge = smoothstep(0.2, 0.0, abs(vUv.y - 0.5));
                vec3 color = mix(vec3(0.1, 0.15, 0.4), vec3(0.5, 0.2, 0.9), glow);
                gl_FragColor = vec4(color, edge * opacity * glow);
                if (gl_FragColor.a < 0.01) discard;
              }
            `,
          })
        );
        nebula.position.set(
          (Math.random() - 0.5) * 8,
          Math.random() * 2 + 0.5,
          -2 - Math.random() * 4
        );
        nebula.rotation.y = Math.random() * Math.PI * 2;
        nebula.rotation.x = -0.2 + Math.random() * 0.4;
        nebulaGroup.add(nebula);
      }
      scene.add(nebulaGroup);

      const shardGroup = new THREE.Group();
      const shardData = [];
      for (let i = 0; i < 48; i++) {
        const geo = new THREE.BoxGeometry(0.16, 0.9 + Math.random() * 1.4, 0.16);
        const mat = new THREE.MeshStandardMaterial({
          color: new THREE.Color().setHSL(0.55 + Math.random() * 0.1, 0.85, 0.6),
          metalness: 0.65,
          roughness: 0.25,
          emissive: 0x051021,
          emissiveIntensity: 0.9,
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.castShadow = true;
        const radius = 2.4 + Math.random() * 2.6;
        const angle = Math.random() * Math.PI * 2;
        const height = (Math.random() - 0.5) * 2.4;
        mesh.position.set(Math.cos(angle) * radius, height, Math.sin(angle) * radius);
        shardGroup.add(mesh);
        shardData.push({
          mesh,
          baseY: height,
          radius,
          angle,
          floatSpeed: 0.4 + Math.random() * 0.7,
          orbitSpeed: 0.2 + Math.random() * 0.3,
        });
      }
      scene.add(shardGroup);

      const sparkGeo = new THREE.BufferGeometry();
      const sparkCount = 600;
      const sparkPositions = new Float32Array(sparkCount * 3);
      for (let i = 0; i < sparkCount; i++) {
        const i3 = i * 3;
        const radius = 6 + Math.random() * 10;
        const angle = Math.random() * Math.PI * 2;
        const height = (Math.random() - 0.5) * 6;
        sparkPositions[i3] = Math.cos(angle) * radius;
        sparkPositions[i3 + 1] = height;
        sparkPositions[i3 + 2] = Math.sin(angle) * radius;
      }
      sparkGeo.setAttribute("position", new THREE.BufferAttribute(sparkPositions, 3));
      const sparks = new THREE.Points(
        sparkGeo,
        new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.06,
          transparent: true,
          opacity: 0.35,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
        })
      );
      scene.add(sparks);

      const meteorGroup = new THREE.Group();
      const meteorData = [];
      for (let i = 0; i < 8; i++) {
        const meteor = new THREE.Mesh(
          new THREE.SphereGeometry(0.07 + Math.random() * 0.04, 16, 16),
          new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(0.55 + Math.random() * 0.3, 0.9, 0.7),
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
          })
        );
        meteorGroup.add(meteor);
        meteorData.push({
          mesh: meteor,
          radius: 3 + Math.random() * 4,
          height: -0.5 + Math.random() * 2.5,
          speed: 0.4 + Math.random() * 0.8,
          offset: Math.random() * Math.PI * 2,
        });
      }
      scene.add(meteorGroup);

      const grid = new THREE.LineSegments(
        new THREE.WireframeGeometry(new THREE.PlaneGeometry(28, 28, 30, 30)),
        new THREE.LineBasicMaterial({
          color: 0x4af0ff,
          transparent: true,
          opacity: 0.12,
        })
      );
      grid.rotation.x = -Math.PI / 2;
      grid.position.y = -2;
      scene.add(grid);

      const monolithMaterial = new THREE.MeshStandardMaterial({
        color: 0x050b18,
        emissive: 0x0a2c4f,
        emissiveIntensity: 1.4,
        metalness: 0.4,
        roughness: 0.5,
      });
      const monolith = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 3.2, 0.6),
        monolithMaterial
      );
      monolith.position.set(0, 0.6, -0.4);
      monolith.rotation.y = Math.PI / 4;
      monolith.castShadow = true;
      scene.add(monolith);

      const ambient = new THREE.AmbientLight(0x16263b, 0.55);
      scene.add(ambient);

      const keyLight = new THREE.DirectionalLight(0xb7d0ff, 1.35);
      keyLight.position.set(6, 8, 4);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.set(1024, 1024);
      scene.add(keyLight);

      const rimLight = new THREE.PointLight(0xff4fb0, 0.9, 12);
      rimLight.position.set(-4, 2.4, 2.3);
      scene.add(rimLight);

      const spotLight = new THREE.SpotLight(0x7dfbff, 2.2, 24, Math.PI / 4, 0.45, 1.2);
      spotLight.position.set(0, 5, 4);
      spotLight.castShadow = true;
      spotLight.shadow.mapSize.set(1024, 1024);
      scene.add(spotLight);
      spotLight.target = monolith;

      let scrollTarget = 0;
      let scrollCurrent = 0;

      const handleScroll = () => {
        const doc = document.documentElement;
        const maxScroll = doc.scrollHeight - window.innerHeight;
        scrollTarget = maxScroll > 0 ? window.scrollY / maxScroll : 0;
      };

      window.addEventListener("scroll", handleScroll);
      handleScroll();

      const clock = new THREE.Clock();

      const animate = () => {
        const delta = clock.getDelta();
        scrollCurrent += (scrollTarget - scrollCurrent) * 0.08;

        const timeFactor = reduceMotion ? 0.45 : 1;
        portalUniforms.uScroll.value = scrollCurrent;
        portalUniforms.uTime.value += delta * (1.2 * timeFactor);
        waterUniforms.time.value += delta * 0.9;
        waterUniforms.scroll.value = scrollCurrent;
        applyPalette(scrollCurrent);

        portalMesh.rotation.z += 0.12 * delta * timeFactor;
        halo.rotation.z -= 0.05 * delta * timeFactor;
        portalMesh.rotation.y = pointer.x * 0.15;
        portalMesh.rotation.x = Math.PI / 2 + pointer.y * 0.1;
        halo.rotation.x = Math.PI / 2 + pointer.y * 0.05;

        helixGroup.rotation.y += 0.25 * delta * timeFactor;
        helixGroup.rotation.x = scrollCurrent * 0.4;

        lightCone.scale.y = 1.1 + Math.sin(clock.elapsedTime * 0.8) * 0.1;
        lightCone.material.opacity = 0.18 + scrollCurrent * 0.25;

        orbGroup.children.forEach((orb, idx) => {
          const angle = clock.elapsedTime * (0.6 + idx * 0.18) + scrollCurrent * Math.PI * 2;
          const radius = 0.9 + idx * 0.35;
          orb.position.x = Math.cos(angle) * radius * 0.6;
          orb.position.z = Math.sin(angle) * radius * 0.6;
          orb.position.y = 0.4 + Math.sin(angle * 2.0) * 0.2;
        });

        shardData.forEach((data, idx) => {
          data.angle += data.orbitSpeed * delta * 0.5 * timeFactor;
          data.mesh.position.x = Math.cos(data.angle) * data.radius;
          data.mesh.position.z = Math.sin(data.angle) * data.radius;
          data.mesh.position.y =
            data.baseY + Math.sin(clock.elapsedTime * data.floatSpeed + idx) * 0.25;
          data.mesh.rotation.y += 0.35 * delta * timeFactor;
        });

        monolith.rotation.y += 0.08 * delta * timeFactor;
        monolith.position.y = 0.6 + Math.sin(scrollCurrent * Math.PI) * 0.3;

        nebulaUniforms.forEach((uniforms, idx) => {
          uniforms.time.value = clock.elapsedTime * (0.2 + idx * 0.05) + scrollCurrent * 2;
        });
        nebulaGroup.rotation.y = scrollCurrent * 0.3;

        meteorData.forEach((data, idx) => {
          const phase = clock.elapsedTime * data.speed + scrollCurrent * 4 + data.offset;
          const radius = data.radius + Math.sin(phase * 0.5) * 0.4;
          data.mesh.position.x = Math.cos(phase) * radius;
          data.mesh.position.z = Math.sin(phase) * radius;
          data.mesh.position.y = data.height + Math.sin(phase * 1.6 + idx) * 0.3;
          data.mesh.material.opacity = 0.25 + 0.65 * Math.abs(Math.sin(phase));
        });
        meteorGroup.rotation.y = -scrollCurrent * 0.5;

        sparks.rotation.y += 0.01 * delta;
        grid.rotation.z = scrollCurrent * 0.2;
        grid.position.y = -2 + Math.sin(clock.elapsedTime * 0.3) * 0.1;

        skyUniforms.time.value += delta * 0.6;

        const camAngle = scrollCurrent * Math.PI * 1.5 + clock.elapsedTime * 0.08;
        const orbitRadius = 2.4 + scrollCurrent * 1.6;
        const parallaxX = pointer.x * 0.4;
        const parallaxY = pointer.y * 0.3;
        camera.position.x = Math.cos(camAngle) * orbitRadius + parallaxX;
        camera.position.z = Math.sin(camAngle) * orbitRadius + 1.5;
        camera.position.y = (scrollCurrent - 0.5) * 3.2 + parallaxY;
        camera.lookAt(parallaxX * 0.5, 0.2 + parallaxY * 0.5, 0);

        if (composer) {
          composer.render();
        } else {
          renderer.render(scene, camera);
        }
        requestAnimationFrame(animate);
      };

      animate();

      const handleResize = () => {
        const { innerWidth: w, innerHeight: h } = window;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
        if (composer) {
          composer.setSize(w, h);
          if (bloomPass && bloomPass.setSize) {
            bloomPass.setSize(w, h);
          }
        }
      };

      window.addEventListener("resize", handleResize);
    </script>
  </body>
</html>
